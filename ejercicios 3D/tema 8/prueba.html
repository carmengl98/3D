<!--
- Funcionalidad avanzada (ángulo de rebote variable, velocidad de desplazamiento vertical variable, posibilidad de ganar a la CPU

- Mejoras:
-Introducir niveles de dificultad. Pueden ser configurable al iniciar el juego o ir
aumentando según se juego una y otra vez.
- Marcador con gráfico 3D en lugar de como texto HTML.
- Posibilidad de elegir diferentes texturas para los elementos de juego (“skin”).
- Animaciones adicionales (movimiento de la cámara o punto de luz en función del
juego).....
-->
<!DOCTYPE html>
<html>

<head>
<title>Three.js: Collision detection</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
<style>
  body{
    text-align: center;
    font-style: italic;
  }
  button{
    width: 140px;
    height: 50px;
    font-Size:15px;
    background-color: #414245;
    border-color: white;
    border-radius: 40px;
    margin-right: 90px;
    color: white;
    font-style: italic;
  }
  img{
    width: 50px;
    height: 50px;
  }
</style>

<script>
   var renderer;
   var stepX = 0;
   var stepY = 0;
   var puntos_cpu = 0;
   var puntos_player = 0;
   var inicio = false;
   var marcador =("CPU: " + puntos_cpu + ' - ' +"USER: " + puntos_player);

   function init() {
      var scene = new THREE.Scene();
      var sceneWidth = window.innerWidth - 20;
      var sceneHeight = window.innerHeight - 20;

      var camera = new THREE.PerspectiveCamera(90, sceneWidth / sceneHeight, 0.01, 100);
      camera.position.set(0, -15, 15);
      camera.lookAt(scene.position);

      renderer = new THREE.WebGLRenderer({
         antialias : true
      });

      renderer.shadowMap.enabled = true;
      renderer.setSize(sceneWidth, sceneHeight);
      document.body.appendChild(renderer.domElement);

      var light = getLight(scene);
      var leftBorder = getBorder("left", 1, 20, 2, -5, 0, 0);
      var rightBorder = getBorder("right", 1, 20, 2, 5, 0, 0);
      var cpu = getBorder("cpu", 3, 1, 2, 0, 10, 0);
      var player = getBorder("player", 3, 1, 2, 0, -10, 0);
      var pelota = getPelota();
      var floor = getFloor();
      var text = getText(scene);

      //añado a la escena
      scene.add(light);
      scene.add(leftBorder);
      scene.add(rightBorder);
      scene.add(cpu);
      scene.add(player);
      scene.add(pelota);
      scene.add(floor);
      var axes = new THREE.AxesHelper(40);
      scene.add(axes);
      //ejex-- rojo   ejey-- verde  ejez-- azul

      var border = [ leftBorder, rightBorder, cpu, player ];

      stepPelota();
      animate(pelota, border, renderer, scene, camera);

   }

   function animate(pelota, border, renderer, scene, camera) {
      checkCollision(pelota, border);

      cpu = border[2];
      player = border[3];

      if (inicio){
          pelota.position.x += stepX;
          pelota.position.y += stepY;
          move_cpu(pelota, border);
      }

      document.onkeydown = function(ev) {
         switch (ev.keyCode) {
          // left
          case 37:
            console.log('left!');
            player.position.x -= 0.3;
            console.log(player.position.x);
            break;
          // Right
          case 39:
            console.log('Right!');
            player.position.x += 0.3;
            console.log(player.position.x);
            break;
          //Space
          case 32:
            inicio = true;
            if (puntos_cpu == 3 || puntos_player == 3){
              puntos_player = 0;
              puntos_cpu = 0;
            }
            reinicio(pelota);
            break;

          default:
             break;
         }
      }

      getMarcador(pelota, border);
      renderer.render(scene, camera);

      requestAnimationFrame(function() {
         animate(pelota, border, renderer, scene, camera);
      });
   }

   function reinicio(pelota){
     pelota.position.x = 0;
     pelota.position.y = 0;
   }

   function stepPelota(){
     //-- Cambiar las velocidades de la bola según el nivel del juego
     document.getElementById('nivel1').onclick = () => {
        console.log('N1');
        stepX = 0.15;
        stepY = 0.15;
      }
      document.getElementById('nivel2').onclick = () => {
        console.log('N2');
        stepX = 0.25;
        stepY = 0.25;
      }
      document.getElementById('nivel3').onclick = () => {
        console.log('N3');
        stepX = 0.5;
        stepY = 0.5;
      }
   }

   function move_cpu(pelota, border){
     cpu = border[2];

     cpu.position.x = pelota.position.x;
     //cpu.position.x += Math.random()-0.1;

     console.log(cpu.position.x);

   }

   function getText(scene){
   var loader = new THREE.FontLoader();

   loader.load( 'fonts/helvetiker_regular.typeface.json', function (font) {
     var geometry = new THREE.TextGeometry( marcador, {
        font: font,
        size: 2,
        height: 0.5,
        curveSegments: 12,
        bevelEnabled: false,
        bevelThickness: 2,
        bevelSize: 0.1,
        bevelOffset: 0.1,
        bevelSegments: 0.1
      } );
     var material = new THREE.MeshNormalMaterial();
     var mesh = new THREE.Mesh(geometry, material);
     mesh.position.y = 30;
     mesh.position.x =-10;
     mesh.rotation.x = 1;
     scene.add(mesh);
     } );

   }

   function getLight(scene) {
      var light = new THREE.DirectionalLight();
      light.position.set(10, 0, 10);
      light.castShadow = true;
      light.shadow.camera.near = -10;
      light.shadow.camera.far = 20;
      light.shadow.camera.left = -20;
      light.shadow.camera.right = 20;
      light.shadow.camera.top = 15;
      light.shadow.camera.bottom = -15;
      light.shadow.mapSize.width = 4096;
      light.shadow.mapSize.height = 4096;
      var helper = new THREE.CameraHelper(light.shadow.camera);
      scene.add(helper);
      return light;
   }

   function getPelota() {
      var geometry = new THREE.SphereGeometry(1, 15, 15);
      var material = new THREE.MeshNormalMaterial();
      var mesh = new THREE.Mesh(geometry, getMaterial("texturas/earth.png"));
      mesh.position.z = 1;
      mesh.castShadow = true;

      return mesh;
   }

   function getFloor() {
      var geometry = new THREE.PlaneGeometry(10, 20);
      var mesh = new THREE.Mesh(geometry, getMaterial("texturas/table.jpg"));
      mesh.receiveShadow = true;

      return mesh;
   }

   function getBorder(name, x, y, z, posX, posY, posZ) {
      var geometry = new THREE.BoxGeometry(x, y, z);
      if (name == 'cpu'|| name == 'player'){
        var mesh = new THREE.Mesh(geometry, getMaterial("texturas/paleta.jpg"));
      }else {
        var mesh = new THREE.Mesh(geometry, getMaterial("texturas/wood.png"));
      }
      mesh.receiveShadow = true;
      mesh.position.set(posX, posY, posZ);
      mesh.name = name;

      return mesh;
   }

   function getMaterial(typeTexture) {
      var texture = new THREE.ImageUtils.loadTexture(typeTexture);
      texture.needsUpdate = true;
      var Material = new THREE.MeshLambertMaterial({
      map : texture,
      });

      Material.map.wrapS = Material.map.wrapT = THREE.RepeatWrapping;
      Material.map.repeat.set(1, 1);
      Material.side = THREE.DoubleSide;

      return Material;
   }

   function checkCollision(pelota, border) {
      var originPosition = pelota.position.clone();
      var leftSide = border[0];
      var rightSide = border[1];
      var pala_cpu = border[2];
      var pala_jugador = border[3];

      for (var i = 0; i < pelota.geometry.vertices.length; i++) {
         var localVertex = pelota.geometry.vertices[i].clone();
         var globalVertex = localVertex.applyMatrix4(pelota.matrix);
         var directionVector = globalVertex.sub(pelota.position);
         var ray = new THREE.Raycaster(originPosition, directionVector.clone().normalize());
         var collisionResults = ray.intersectObjects(border);
         if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
            // Collision detected
            if (collisionResults[0].object.name == "left" || collisionResults[0].object.name == "right") {
               stepX *= -1;
            }
            if (collisionResults[0].object.name == "player"){
               if (rightSide.position.x - pala_jugador.position.x  <= 9 ){
                 console.log('diferencia 1!!', rightSide.position.x - pala_jugador.position.x );
                 pelota.position.x += stepX;
                 console.log('posicion y',pelota.position.y);
                  console.log('posicion x',pelota.position.x);

               }else{
                 console.log('no diferencia 1!!', rightSide.position.x - pala_jugador.position.x );
                 pelota.position.x -= stepX;
                 console.log('posicion y',pelota.position.y);
                  console.log('posicion x',pelota.position.x);
               }
               if (leftSide.position.x - pala_jugador.position.x  <= -9 ){
                 console.log('diferencia 2!!', leftSide.position.x - pala_jugador.position.x );
               }else{
                 console.log('no diferencia 2!!', leftSide.position.x - pala_jugador.position.x );
               }
              stepY *= -1;

            }else if (collisionResults[0].object.name == "cpu") {
               stepY *= -1;
            }

            break;
         }
      }
   }

   function getMarcador(pelota, border){
     if (pelota.position.y >= border[2].position.y){
       puntos_cpu += 1;
       inicio = false;
       reinicio(pelota);

     }else if (pelota.position.y <= border[3].position.y){
       puntos_player += 1;
       inicio = false;
       reinicio(pelota);
     }
     document.getElementById("puntos").innerHTML = ("CPU: " + puntos_cpu + ' - ' +"USER: " + puntos_player);
     if (puntos_player == 3 || puntos_cpu == 3){
       if (puntos_player > puntos_cpu){
         console.log("Ha ganado el USER!!!");
       }else{
         console.log("Ha ganado la CPU!!!");
       }
       inicio = false;
     }

   }

</script>
</head>

<body onload="init()">
  <h1>PONG EN 3D</h1>
  <h3>INSTRUCCIONES DEL PONG:</h3>
  <p>Pong es un juego en dos dimensiones que simula un tenis de mesa. El objetivo
     consiste en que uno de los jugadores consiga llegar a 5 puntos antes que el
     oponente; este será el GANADOR. Estos puntos se obtienen cuando el jugador
     adversario falla al devolver la pelota. En este juego el jugador controla una
     paleta y competirá contra un oponente controlado por computadora.</p>
  <h3>MOVIMIENTOS:</h3>
  <img src="texturas/derecha.png" alt="."><br>
  <img src="texturas/izquierda.png" alt="."><br>
  <h3>NIVELES:</h3>
  <p>Elegir un nivel de juego antes de empezar a jugar.</p>
  <button type="button" id="nivel1">Fácil</button>
  <button type="button" id="nivel2">Medio</button>
  <button type="button" id="nivel3">Difícil</button><br><br>
  <p id="puntos"></p>
</body>

</html>
